import 'package:flutter_cryptocurrency_app/data/crypto_data.dart';
import 'package:flutter_cryptocurrency_app/data/crypto_data_mock.dart';
import 'package:flutter_cryptocurrency_app/data/crypto_data_prod.dart';

enum Flavor { MOCK, PROD }
// Enumerations serve the purpose of representing a group of named constants in a programming language.

// singleton class is a constructor which returns/use only one object instead of making different object on different instantiation

class Injector {
  static final Injector _singleton = new Injector._internal();
  // If an instance variable already exists, it is returned. Otherwise, a new instance is generated by calling the named generative constructor Injector._internal

  static Flavor _flavor;

  static void configure(Flavor flavor) {
    _flavor = flavor;
  }

  factory Injector() {
    return _singleton;
  }

  Injector._internal();

  CryptoRepository get cryptoRepository {
    switch (_flavor) {
      case Flavor.MOCK:
        return new MockCryptoRepository();
      default:
        return new ProdCryptoRepository();
    }
  }
}

//  Use a factory in situations where you don't necessarily want to return a new instance of the class itself. Use cases:

// the constructor is expensive, so you want to return an existing instance - if possible - instead of creating a new one;
// you only ever want to create one instance of a class (the singleton pattern);
// you want to return a subclass instance instead of the class itself.
// A Dart class may have generative constructors or factory constructors. A generative constructor is a function that always returns a new instance of the class. Because of this, it does not utilize the return keyword. A common generative constructor is of the form:

// class Person {
//   String name;
//   String country;

//   // unnamed generative constructor
//   Person(this.name, this.country);
// }
// var p = Person("...") // returns a new instance of the Person class
// A factory constructor has looser constraints than a generative constructor. The factory need only return an instance that is the same type as the class or that implements its methods (ie satisfies its interface). This could be a new instance of the class, but could also be an existing instance of the class or a new/existing instance of a subclass (which will necessarily have the same methods as the parent). A factory can use control flow to determine what object to return, and must utilize the return keyword. In order for a factory to return a new class instance, it must first call a generative constructor.

// In your example, the unnamed factory constructor first reads from a Map property called _cache (which, because it is Static, is stored at the class level and therefore independent of any instance variable). If an instance variable already exists, it is returned. Otherwise, a new instance is generated by calling the named generative constructor Logger._internal. This value is cached and then returned. Because the generative constructor takes only a name parameter, the mute property will always be initialized to false, but can be changed with the default setter:

// https://stackoverflow.com/questions/53886304/understanding-factory-constructor-code-example-dart
